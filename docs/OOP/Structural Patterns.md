[[GRASP]]
[[Creational patterns]]

##### **Adapter**
По своей сути паттерн Адаптер очень прост. Его реализация заключается в создании обертки на обьектом, имплементирубщей нужный интерфейс. Имлементация етодов интерфейса, соответственно, должна выглядеть как преобразование аргументов и вызов методов у оборачиваемого обьекта. 
	Target - целевой интерфейс, который имплементирует класс обертка
	Adaptee - оборачиваемый обьект
	Adapter - обьект-обертка

Паттерн Адаптер можно использовать как опсредника для достижения полиморфизма между типами не находящимися в одной иерархии. Он является склейкой между обьектами имеющими различные интерфейсы. 
Применение адаптера может быть полезно в ситуациях, когда код обьединяемых типов не может быть изменен, либо когда его изменения несут за собой сольные риски. 
```C#
public class SqlServerLogSaver
{
		public void Save(string message, DateTime timeStamp, int severity) { ... }
}

public class ElasticLogSaver
{
		public void Save(ElasticLogMessage message);
}

public interface ILogSaver
{
		void Save(LogEntry entry);
}

public SqlServerLogSaverAdapter : ILogSaver
{
		private readonly SqlServerLogSaver _saver;

		public void Save(LogEntry entry)
		{
				_saver.Save(entry.Message, entry.DateTime, entry.Severity.AsInteger());
		}
}

public ElasticLogSaverAdapter : ILogSaver
{
		private readonly ElasticLogSaver _saver;

		public void Save(LogEntry entry)
		{
				_saver.Save(entry.AsElasticLogMessage());
		}
}
```
Паттерн адаптер может быть использован для локализации рефакторинга. Предположим вы проводите рефакторинг кода, который требует изменение интерфейса используемых обьектов (добавление асинхронности в нашу систему логирования). На первый взгляд, это приведет к тому, что придется изменять как код, используюзий старые интерфейсы (на использование новых), так и код, реализующий старые интерфейсы (на реализацию новых). 
Изменения можно локализовать путем добавления адаптера, из старого интерфейса в новый, соответственно рефакторинг можно разбить на два шага, изменение использований, изменение реализаций, после которых добавленные адаптеры можно будет удалить за ненадобностью. 


##### Bridge
Суть паттерна мост заключается в введении в систему абстракций более высокого уровня, реализации которых работают со сложными абстракциями более низкого уровня. 
Использование паттерна помогает абстрогировать клиентский код от сложности абстракций используемых для достижения реализации требуемой логики. 
В целом паттерн мост является указанием хорошего тона к проектированию интерфейсов для приложения. Его использование удостоверяет инкапсуляцию логики в отдельных модулях и на клиентский код не ложится ответственность за реализацию логики, которую он не должен нести. Форсит SRP
```C#
public interface ITelevision
{
		int Volume { get; set; }

		int Channel { get; set; }
}

public interface IRemote
{
		void IncreaseVolume();

		void DecreaseVolume();

		void NextChannel();

		void PreviousChannel();
}

public class Remote : IRemote
{
		private readonly ITelevision _tv;
		private readonly int _step;

		public Remote(ITelevision tv, int step)
		{
				ArgumentNullException.ThrowIfNull(tv);

				_tv = tv;
				_step = ValidateStep(step);
		}

		public void IncreaseVolume()
		{
				_tv.Volume += step;
		}

		public void DecreaseVolume()
		{
				_tv.Volume -= step;
		}

		public void NextChannel()
		{
				_tv.Channel += 1;
		}

		public void PreviousChannel()
		{
				_tv.Channel -= 1;
		}

		private static int ValidateStep(int value) { ... }
}
```

##### **Composite**
Паттерн компоновщик позволяет работать с древовидной структурой обьектов как с одним обьектом. 
Паттерн стоит использовать когда проектируемая модель представляется в виде древовидной / иерархической структуры. 

Для реализации паттерна нужен базовый интерфейс для компонентов дерева компоновщика. В структуре компоновщика существует два вида узлов: терминальные и агрегаты. При чем оба вида могут быть представлены различными типами. 
Обычно паттерн компоновщик реализуется вместе с паттерном Visitor, для отделения логики обработки компонентов от самих компонентов. Такой подход позволяет добавлять различное поведение над одной композицией обьектов. 

Компоненты так же могут иметь свое поведение опять же зависит от юзкейса, но в основном компоненты содержат логику стейт менеджмента и логику диспатча вызова в визитор. 

##### **Decorator**
По своей сути декоратор - способ. расширять поведения типа через композицию (агрегацию), а не наследование. 
Декоратор и оборачиваемый обьект должны реализовывать один интерфейс. Декоратор расширяет логику, выполняемую оборачиваемым обьектом, соответственно декоратор всегда должен вызывать соответствующие поведения оборачиваемого обьекта. Декоратор не изменяет реализуемый интерфейс, он лишь расширяет реализацию поведения. 
Декоратор используется тогда, когда нужно добавить что-то к поведениям существующего обьекта, прозрачно для пользовательского кода
```C#
public interface IService
{
		void DoStuff(DoStuffArgs args);
}

public class Service : IService
{
		public void DoStuff(DoStuffArgs args) { ... }
}


// Простой инфраструктурный интерфейс для примера добавления логики над сервисом
public interface ILogger
{
		void Log(string message);
}

public class LoggingServcieDecorator : IService
{
		private readonly IService _decoratee;
		private readonly ILogger _logger;

		public void DoStuff(DoStuffArgs args)
		{
				_logger.Log(ArgsToLogMessage(args));

				_decoratee.DoStuff(args);
		}
		
		private static string ArgsToLogMessage(DoStuffArgs args) { ... }
}
```

##### **Facade**
В общем фасадом называют простую абстракцию над сложной логикой. Фасады обычно представляются в системах в виде сервисов, которые инкапсулируют сложную логику и могут использовать другие сервисы и модули в ее реализации. Интерфейсы фасадов содержат методы, для различных юзкейсов системы.
Фасады используются для абстракции клиентского кода от сложных деталей реализации, разделения системы на слои, используя фасады как входные точки в конкретный слой. 
Данный паттерн имеет схожесть с паттерном Посредник и паттерном Indirect из GRASP

Использование фасадов может повлечь создания класса-бога в системе, т.е. класса, зависимого от всех типов системы. Это приводит к нарушению SRP, сильной связанности, проблемам с рефакторингом и расширяемостью. Обширные фасады приводят к появлению приватной логики шареной между методами фасада, вместо инкапсуляции её в каких-либо абстракциях, которые позволят её переиспользовать в других модулях, это приводит к проблемам при декомпозиции фасадов.

При проектировании фасадов, стоит минимизировать скоуп их ответственности, в идеале, использование паттера фасад должно приходить к request-response модели, таким образом каждый фасад ответственен за один юзкейс слоя. Такой подход форсит разработчиков инкапсулировать шареную логику в соответсвующих абстракциях, которые можно будет переиспользовать в других фасадах и модулях.

##### **Flyweight**
Паттерн **Легковес** это способ проектирования типов, с рассчётом на оптимизацию использования памяти. Смысл паттерна **Легковес** заключается выделении из часто используемых объектов общих неизменяемых частей, обычно занимающих большие объемы памяти, в другой тип, объекты которого будут агрегированы изначальными объектами.

При таком подходе, убирается дупликация данных в памяти, так как объекты будут ссылаться на общие данные.

Смысл нейминга заключается в том, что конечные объекты, те что будут многочисленны, будут легковесны, т.е. будут держать только ссылку на данные большого размера.

##### **Proxy**
Паттерн Заместитель - способ контролировать то, как клиентский код взаимодействует с объектом, не внося эту логику в сам объект.

Есть различные виды типов заместителей:

- Виртуальный заместитель Инкапсулирует в себе отложенную инициализацию оборачиваемого объекта.
- Защищающий заместитель Инкапсулирует логику доступа клиентского кода к объекту. Такие заместители могут получать информацию о пользователе, основываясь на которой, определяют - давать доступ к выполнению операций или нет.
- Кеширующий заместитель Добавляет логику кеширования результатов выполнения операций оборачиваемым объектом.
- Удалённый заместитель Используется для перенаправления вызовов на удалённые ресурсы (remoting, RPC, итд).

##### **Decorator vs Proxy**
Основополагающим принципом паттерна **Заместитель** является композиция. Этим он имеет схожесть с паттерном **Декоратор**, чем зачастую путает людей, соответсвенно многие не знают различия между ними. Несмотря на общую основу - композицию, реализация паттернов довольно сильно отличается.

- Виды композиции Так как Заместитель может управлять оборачиваемым объектом, то в рамках его реализации допускается использование как агрегации, так и ассоциации. Декоратор же, не подразумевает какой-либо контроль над оборачиваемым объектом, соответсвенно при его реализации всегда используется агрегация.
- Extended Dispatch vs Controlled Dispatch Заместитель может управлять тем, как вызовы переадресуются оборачиваемому объекту, он может блокировать их, заменять вызов возвратом кешированных данных. При реализации декоратора, мы можем лишь добавлять новые поведения к уже существущим, тем что реализует оборачиваемый объект. Декораторы не должны ни в какой форме блокировать вызовы поведений у оборачиваемых объектов.
- Наличие оборачиваемого объекта Удалённый заместитель может не хранить объект реализующий замещаемый интерфейс, он “замещает” объект с таким интерфейсом, передавая реализацию каким-либо удалённым ресурсам. Декораторы всегда должны иметь оборачиваемый объект.

Подводя итог сравнения. Декоратор это про расширения логики без изменения существующей. Заместитель же, больше про контроль над оборачиваемым объектом, удалённое выполнение как одна из вариаций использования (на самом деле самая популярная вариация)