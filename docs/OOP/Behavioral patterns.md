## **Template method**
Шаблонный метод - поведенческий паттерн проектирования, определяющий основу алгоритма и позволяющий наследникам переопределять некоторые шаги алгоритма, не изменяя его структуру в целом. 

Проще говоря, паттерн описывает скелет алгоритма, перекладывая ответственность на некоторые шаги на подклассы (потомкам). Паттерн позволяет подклассам переопределить шаги алгоритма, не меняя его общей структуры. 

Например: При строительстве дома строители используют множество инструкция как и что делать, но в самом процессе строительства изменяют какие то мелкие части, что бы каждый дома был индивидуален. 

![[Pasted image 20241206181625.png]]

## **Strategy**
Стретегия - поведенческий паттерн проектирования.
Примерно тоже самое, что и шаблонный метод, только разница в том, что в шаблонном методе используется наследование, а в стратегии - композиция

## **Responsibility Chain**
Проблема: хотим иметь настраиваемое подобие switch-case, для этого сделаем обработчики - сущности, которая принимают какое-то значение и решают, что делать: обрабатывать их и/или передавать следующим обработчикам. 

Пример: парсинг аргументов (4 лаба). Пускаем по цепочке обработчиков слово из командной строки: если это какое-то имся аргумента, начинающееся с дефиса, то парсим следующее слово, иначе передаем другому обработчику в цепочке.

В конце имеем обработчиков, каждый из которых ответственен только за одну какую-ту штуку. 

## **Observer**
поведенческий паттерн проектирования, позволяющий "прослушивать" события сущности. 

Другими словами, есть сущность, которая производит какие-то события, и сущности, которые хотят отслеживать эти события. 

Пример: есть годовалый ребенок, о чьих события родители хотели бы знать. В этом случае ребенок - издатель событий, а родители - подписчики. Другой пример: чатик и сообщения, в этом случае чат - это издатель, а пользователи - подписчики.

## **Command**
Понятно из названия лол
Вместо вызова определенного метода, мы создаем обьект команды и вызываем от нее нужный нам метод. В итоге с такими обьектами появляется больше возможностей, чем с обычными методами: их мы можем вызывать, когда и как захотим, например, фильтровать команды, логгировать, устранять дубликаты. 

## **Visitor**
Поведенческий паттерн проектирования, который добавляет логику дополнительных операций без модификации исходного обьекта. 

Пример: (lab4) вывод древа файловой системы

## **Snapshot**
В паттерне есть 2 сущности:
Ориджинатор (Originator) - сущность, снимки которой мы хотим сохранять.
Кейртейкер (Caretaker) - сущность, которая хранит снимки.

По сути снимок -  это просто копия всех полей ориджинатор в конкретный момент времени. Благодаря этом, мы можем вернуть ориджинатор к какому-то предыдущему состоянию из прошлого.

Но в каком-то случае использования, если изменяемый объект тяжелый, а изменения маленькие, то лучше использовать команды

## **State**

Поведенческий паттерн проектирования, реализующий обьекты состояния определенного обьекта. 
По сути, просто конечная машина состояний - представляем обьекты как состояния, а переходы между ними как методы, возвращающие результирующий тип, показывающий, есть такой переход или нет.
## **Iterator**
Итератор - поведенческий паттерн проектирования, представляющий собой обьект, который дает возможность получить последовательный доступ к элементам обьекта, без использования описания каждого из элемента. 

Проще говоря, итератор нужен для последовательного перебора какой-либо коллекции, без получения внутреннего представления элементов этой коллекции

Паттерн, при помощи которого можем проитерироваться по сложному списку.

В С# итерируемые обьекты реализованы через интерфейс IEnumerable, метод GetEnumerator которого возвращает "итератор" - реализацию интерфейса IEnumerator 

